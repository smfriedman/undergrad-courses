//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    private Record[] table;
    private int M;
    private Record deleted; 
    private int occupiedSlots;

    //
    // Create an empty table big enough to hold maxSize records.
    //
    public StringTable(int maxSize) 
    {
//    	M = 1;
//    	while(M < maxSize*4){				
//    		M = M * 2;				//original table from part 1
//    	}
//    	table = new Record[M];
    	
    	M = 2;
    	table = new Record[M];
    	
    	deleted = new Record("0000");		//works because all other keys will be sequences of ATCG, not numbers
    	deleted.setHashValue(toHashKey(deleted.key));
    	
    	occupiedSlots = 0;
    }
    
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	int hashKey = toHashKey(r.key);
    	r.setHashValue(hashKey);
    	int base = baseHash(hashKey);
    	int index = base%M;
    	while(table[index] != null) {	
    		//compare hashes first because it's quicker
    		if(table[index].getHashValue() == (r.getHashValue())){	
    			//if yes, if record is already in table, return false
    			if(table[index].equals(r)) return false;				
    		}
    		//if a deleted record is there, end loop and insert record
    		if(table[index].getHashValue() == deleted.getHashValue()) break;	
    		
    		//increment by step hash
    		base = base + stepHash(hashKey);							
    		index = base%M;
    		
    		//if you've checked all possible slots, it's not there
    		if(index == baseHash(hashKey)) return false;				
    	}
    	
    	//if table[index] is available:
    	occupiedSlots++;
    	if((double)occupiedSlots/(double)M > 0.25){
    		sizeDouble(r);
    	}
    	table[index] = r;
    	r.index = index;
    	return true;
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	table[r.index] = deleted;
    	r.index = -1;
    	r.setHashValue(-1);
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int hashKey = toHashKey(key);
    	int base = baseHash(hashKey);
    	int index = base%M;
    	while(table[index] != null ){
    		//if keys have same hash value, you've found the key
    		if(table[index].getHashValue() == hashKey) {
    			return table[index];
    		}
    		base = base + stepHash(hashKey);
    		index = base%M;
    		
    		//if you've checked every possible place the record could be, you can't find it
    		if(index == baseHash(hashKey)) {
    			return null; 
    		}   
    	}
    	return null; //if s0(hashKey) is null, return null, since the record's not in the table
    }
    
    public void sizeDouble(Record r){
    	//copy current table
    	Record[] copy = table.clone();

    	//double M and change table to double the size
    	M = 2 * M;
    	table = new Record[2 * M];
    	//insert all records from copy into new table using existing method
    	for(int i = 0; i < copy.length; i++){
    		if(copy[i] != null && copy[i].getHashValue() != deleted.getHashValue()) {
    			insert(copy[i]);
    		}			
    	}
    }
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
    	double A = (Math.sqrt(5) - 1) * 0.5;
    	int base = (int) Math.floor((M * (A * hashKey - Math.floor(A * hashKey))));
    	return base;
    }
    
    int stepHash(int hashKey)
    {
    	double A = Math.PI / 5.0;
    	int step = (int) Math.floor((M * (A * hashKey - Math.floor(A * hashKey))));
    	if(step%2 == 0) return step + 1;		//make stepHash odd
    	else return step;
    }
}
